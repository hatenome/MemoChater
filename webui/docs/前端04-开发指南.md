# MemoChater WebUI - 开发指南

## 一、环境准备

### 1.1 依赖安装

```bash
cd G:\MemoChater\webui
npm install
```

### 1.2 开发服务器

```bash
npm run dev
```

访问 http://localhost:5173

### 1.3 生产构建

```bash
npm run build
npm run preview  # 预览构建结果
```

## 二、开发规范

### 2.1 文件命名

| 类型 | 命名规范 | 示例 |
|------|----------|------|
| 组件 | PascalCase | `ChatMessage.vue` |
| 视图 | PascalCase + View | `ChatView.vue` |
| Store | camelCase | `assistant.ts` |
| API | camelCase | `assistants.ts` |
| 类型 | PascalCase | `AssistantConfig` |

### 2.2 组件结构

```vue
<script setup lang="ts">
// 1. 导入
import { ref, computed, onMounted } from 'vue'
import { useRouter } from 'vue-router'
import { useAssistantStore } from '@/stores'

// 2. Props & Emits
const props = defineProps<{
  message: ChatMessage
  index: number
}>()

const emit = defineEmits<{
  edit: [index: number, content: string]
  delete: [index: number]
}>()

// 3. 状态
const loading = ref(false)

// 4. 计算属性
const isValid = computed(() => ...)

// 5. 方法
function handleSubmit() { ... }

// 6. 生命周期
onMounted(() => { ... })
</script>

<template>
  <!-- 模板 -->
</template>

<style scoped>
/* 样式（尽量使用 Tailwind） */
</style>
```

### 2.3 API 调用规范

```typescript
// 使用封装的 api 对象
import { assistantsApi, modelsApi } from '@/api'

// 在 Store 中调用
async function loadAssistants() {
  try {
    assistants.value = await assistantsApi.list()
  } catch (e) {
    app.showToast('加载失败', 'error')
  }
}

// 动态加载模型列表
async function loadModels() {
  try {
    const models = await modelsApi.list()
    modelOptions.value = models.map(m => m.id)
  } catch (e) {
    // 使用默认值
    modelOptions.value = ['gpt-4o', 'gpt-4o-mini']
  }
}

// 在组件中通过 Store 调用
const store = useAssistantStore()
await store.loadAssistants()
```

### 2.4 状态管理规范

```typescript
// stores/assistant.ts
export const useAssistantStore = defineStore('assistant', () => {
  // 状态
  const assistants = ref<AssistantSummary[]>([])
  const messages = ref<ChatMessage[]>([])
  
  // 计算属性
  const currentAssistant = computed(() => 
    assistants.value.find(a => a.id === currentAssistantId.value)
  )
  
  // 方法
  async function loadAssistants() { ... }
  
  // 消息操作方法
  async function editMessage(index: number, content: string) { ... }
  async function removeMessage(index: number) { ... }
  async function createBranchFromMessage(index: number, title?: string) { ... }
  
  // 返回
  return {
    assistants,
    messages,
    currentAssistant,
    loadAssistants,
    editMessage,
    removeMessage,
    createBranchFromMessage,
  }
})
```

## 三、常见任务

### 3.1 添加新页面

1. 创建视图组件 `src/views/NewView.vue`
2. 在 `src/router.ts` 添加路由
3. 在 `Sidebar.vue` 添加导航入口（如需要）

### 3.2 添加新 API

1. 在 `src/api/` 下创建或修改文件
2. 在 `src/api/index.ts` 导出
3. 在 Store 中封装调用逻辑

**示例：添加模型列表API**
```typescript
// api/index.ts
export const modelsApi = {
  list: () => api.get<ModelInfo[]>('/admin/api/models'),
}
```

### 3.3 添加新组件

1. 创建组件 `src/components/NewComponent.vue`
2. 定义 Props 和 Events
3. 在需要的地方导入使用

### 3.4 修改主题色

编辑 `tailwind.config.js`：

```javascript
theme: {
  extend: {
    colors: {
      primary: {
        // 修改主色调
      }
    }
  }
}
```

## 四、调试技巧

### 4.1 Vue DevTools

安装 Vue DevTools 浏览器扩展，可以：
- 查看组件树
- 检查 Pinia 状态
- 追踪路由变化

### 4.2 网络请求

打开浏览器开发者工具 Network 面板：
- 检查 API 请求/响应
- 查看 SSE 流式数据

### 4.3 控制台日志

```typescript
// 开发时添加日志
console.log('[ChatView] sendMessage:', content)
console.log('[Store] assistants loaded:', assistants.value)
console.log('[loadModels] 获取到模型:', models)
```

## 五、构建部署

### 5.1 构建

```bash
npm run build
```

产物在 `dist/` 目录。

### 5.2 部署选项

**选项 1：静态文件服务**
```bash
# 使用任意静态服务器
npx serve dist
```

**选项 2：集成到后端**
将 `dist/` 内容复制到后端静态文件目录，由后端服务。

**选项 3：Nginx**
```nginx
server {
    listen 80;
    root /path/to/dist;
    
    location / {
        try_files $uri $uri/ /index.html;
    }
    
    location /api {
        proxy_pass http://localhost:7892;
        rewrite ^/api(.*)$ $1 break;
    }
}
```

## 六、已知问题

### 6.1 API 代理

开发模式下 `/api` 前缀会被代理，生产环境需要配置反向代理或修改 API 地址。

### 6.2 流式响应

SSE 流式响应需要后端正确设置 `Content-Type: text/event-stream`。

### 6.3 CORS

后端已配置 CORS，如遇跨域问题检查后端 `CorsLayer` 配置。

### 6.4 动态模型列表

模型列表从 `/admin/api/models` 获取，该接口代理到配置的 AI API。如果 AI API 不可用，会使用默认模型列表。

### 6.5 模型配置说明 ⭐

助手的四种模型配置会被后端正确使用：
- **主模型** - 用于对话生成
- **处理模型** - 用于记忆处理（2号AI）
- **Embedding模型** - 用于记忆向量化和检索
- **提取模型** - 用于信息提取（待集成）

不同助手可以配置不同的模型，包括不同的 embedding 模型。

### 6.6 后处理完成通知 ⭐ 新增

流式对话完成后，后端会执行后处理器（如 ContentChunker），完成后发送特殊事件：

**后端事件序列：**
```
data: {"choices":[{"delta":{"content":"..."}}]}
data: {"choices":[{"finish_reason":"stop"}]}
data: [DONE]
... 后处理执行 ...
data: [POST_PROCESS_DONE]
```

**前端处理：**
```typescript
for await (const chunk of stream) {
  if (typeof chunk === 'object' && chunk.type === 'post_process_done') {
    await loadPacketMemory()  // 刷新数据
    continue
  }
  // 处理普通内容
}
```

### 6.7 记忆话题数据源 ⭐ 新增

记忆话题的消息列表从 packet 获取，而非 history.json：

```typescript
// stores/assistant.ts - selectTopic
if (topic?.topic_type === 'memory') {
  const packetData = await assistantsApi.getPacketMemory(assistantId, topicId)
  messages.value = packetData.messages || []
} else {
  messages.value = await assistantsApi.getHistory(assistantId, topicId)
}
```

### 6.8 短期记忆结构化 ⭐ 新增 (2026-01-04)

短期记忆已从单一 content 字段重构为结构化字段：

```typescript
interface ShortTermMemoryEntry {
  id: string
  summary: string      // 概述/标题
  content: string      // 详细内容
  memory_type: string  // 类型（fact/event/preference/knowledge/task/other）
  relevance: number
  source: string
  timestamp: string
}
```

**前端展示：**
- 卡片显示：标题 + 类型标签 + 详细内容
- 编辑模式：概述输入框 + 类型下拉选择 + 内容文本框

**新增短期记忆：**
```typescript
shortTermMemory.value.push({
  id: `mem_${Date.now()}`,
  summary: '新记忆',
  content: '详细内容...',
  memory_type: 'other',
  relevance: 0.5,
  source: 'CurrentConversation',
  timestamp: new Date().toISOString()
})
```### 6.9 历史对话轮次显示 ⭐ 新增 (2026-01-04)

记忆话题中，由于 ContentChunker 会清空对话上下文，前端通过 `conversation_turns` 显示上一轮对话：

```typescript
// 类型定义
interface ConversationTurn {
  user_message: string
  assistant_message: string
  timestamp: string
}

// 状态
const conversationTurns = ref<ConversationTurn[]>([])

// 加载
conversationTurns.value = data.conversation_turns || []

// 显示最后一轮
const lastTurn = conversationTurns.value[conversationTurns.value.length - 1]
```

**前端展示：**
- 消息列表下方显示边框框
- 绿色圆点 + 时间戳
- 用户消息 + AI回复

### 6.10 禁用 Gemini 思考 ⭐ 新增 (2026-01-04)

设置页面新增 toggle 开关，用于禁用 Gemini 模型的思考功能：

```typescript
// 加载设置
const response = await api.get<{ disable_gemini_thinking: boolean }>('/admin/api/settings')
disableGeminiThinking.value = response.disable_gemini_thinking

// 保存设置
await api.put('/admin/api/settings', {
  disable_gemini_thinking: disableGeminiThinking.value
})
```

### 6.11 datetime-local 时间格式 ⭐ 新增 (2026-01-04)

`<input type="datetime-local">` 需要特定格式 `YYYY-MM-DDTHH:mm`，而后端返回 ISO 8601 格式：

```typescript
// 加载时：ISO → datetime-local
editShortTermTimestamp.value = mem.timestamp.slice(0, 16)

// 保存时：datetime-local → ISO
mem.timestamp = new Date(editShortTermTimestamp.value).toISOString()
```

### 6.12 话题快速创建与编辑 ⭐ 新增 (2026-01-05)

话题创建和编辑交互优化：

**创建话题：**
- 点击 `+` 按钮直接创建，标题自动使用当前时间（格式：`MM-DD HH:mm`）
- 无需弹窗输入标题

**编辑话题：**
- 双击话题进入编辑模式
- 按 `Enter` 或失去焦点保存
- 按 `Esc` 取消编辑

```typescript
// 生成时间标题
function generateTimeTitle(): string {
  const now = new Date()
  const month = String(now.getMonth() + 1).padStart(2, '0')
  const day = String(now.getDate()).padStart(2, '0')
  const hour = String(now.getHours()).padStart(2, '0')
  const minute = String(now.getMinutes()).padStart(2, '0')
  return `${month}-${day} ${hour}:${minute}`
}
```

### 6.13 短期记忆预览截断 ⭐ 新增 (2026-01-05)

短期记忆卡片内容预览限制100字符，超出部分显示省略号：

```typescript
// 截断文本（用于预览）
function truncateText(text: string, maxLength: number = 100): string {
  if (!text || text.length <= maxLength) return text
  return text.slice(0, maxLength) + '...'
}

// 模板中使用
{{ truncateText(mem.content, 100) }}
```

编辑模式下仍可查看和编辑完整内容。